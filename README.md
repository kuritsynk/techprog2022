# Технология программирования 2022

## Первый семестр

### Системы контроля версий

Цели: 
* Хранение исходного кода и истории его изменений
* Поддержание целостности изменений
* Возможность совместной разработки

### Пространство имен

Цели:
* Обеспечить уникальность имен
* Стандартная библиотека загружается в стандартное пространство имен `std`.


### Перегрузка функций

Механизм, позволяющий объявлять одноименные функции в одной области видимости 
и в одном пространве.
Декорирование имен функций - это механизм формирования внутреннего имени
функции, включающего типы входных параметров.

### Параметры со значениями по умолчанию

### Передача параметров в функции
* По значению - в функцию передается копия входного значения. Это является 
безопасным способом передачи данных, т.к. вызываемая функция не может изменить 
исходные данные. Минус: низкая эффективность при передачи больших объемов данных.
* Через указатель - в функцию передается по значению указатель на данные.
Этот способ является эффективным для передачи больших объемов данных, но 
вызываемая функция может входные данные изменить (это и минус с т.з. безопасности,
и плюс с т.з. реализации возврата нескольких значений из функции)
* По ссылке - аналогичен передачи через указатель, но синтаксически похож на 
передачу по значению. 

Нельзя возвращать указатели и ссылки на локальные переменные: 
они по выходу из функции - недействительны.

## Объектно-оринтированное программирование (ООП)

### Парадигмы ООП

* Инкапсуляция
Объединение данных и методов по работе с данными. Обеспечивается защита 
данных.

* Наследование
Повторное использование кода и структур данных.

* Полиморфизм
Наличие общего интерфейса.

### Классы

Класс - это тип данных, обеспечивающий парадигмы ООП. Объединяет данные 
и функции по работе с ними. 
Данные в классе - это поля класса, функции - методы класса.
Переменные типа класс - это отдельные экземпляры класса, объекты.

## Области видимости

Все члены класса распологаются в областях видимости: public - 
открытая (публичная) или private - закрытая (приватная) (по умолчанию).
Доступ к открытым членам класса имеется из всех частей программы, где
виден сам класс.
Доступ к закрытым членам класса имеется только у других членов этого класса
и дружественных функций и классов.

## Указатель this

Методы класса - это специальные функции, которые принимают дополнительным
аргументом (неявно) указатель на экземпляр класса, для которого вызывается
метод - указатель `this`.

## Конструктор

Конструктор - это специальный метод класса, который служит для инициализации
его полей (и все). Конструктор имеет имя класса, не возвращает значений.
Конструкторов (перегруженных) может быть несколько. Конструктор без входных
параметров называется конструктором по умолчанию.
Конструктор вызывается автоматически при объявлении переменной класса, 
а также при размещении в динамической памяти при помощи оператора `new`.

## Деструктор

Деструктор - это специальный метод класса, который служит для освобождения
ресурсов, которые были выделены при работе класса.
Деструктор имеет имя класса, предворенное тильдой, не возвращает значений и
не принимает входных параметров.
Деструктор вызывается автоматически при выходе переменной из области видимости,
либо при вызове оператора `delete`.

## Оператор =

Оператор присваивания требуется для корректного копирования структур
с использованием динамической памяти. В операторе должна
корректно обрабатываться ситуация присвоения самому себе.

## Конструктор копирования

Конструктор копирования (КК) - это специальный конструктор, который 
создает объект на основе данных другого объекта этого класса.
КК принимает на вход константную ссылку на объект этого класса.

Отличие оператора присваивания от KK: последний вызывается при
создании нового объекта, а оператор= - для уже существующего.
```
	Vector v4 = v2; // КК: v4.Vector(v2)
	v4 = v2;        // = : v4.operator=(v2)
```

КК вызывает автоматически при передаче параметров в функцию по значению
(и возврате результата по значению)
значений

## Перегрузка операторов

Оператор - это функция или метод, которая имеет специфическую
семантику вызова. Например, оператор сложения `+` может записываться
привычным образом как `a + b`, а не в виде функционального вызова,
например, `+(a, b)`.

С++ позволяет перегружать операторы для математических 
(и не только) операций.

Оператор бывают унарные, бинарные и тернарные.
Унарные операторы предполагают один операнд.
Это, например, `++` - инкремент, `!` - отрицание.

Бинарные операторы используют два операнда.
Это, оператор присваивания `=`, `+`, `-`, 
логические `==`, `>`, `<=`, операции, совмещенные
с присвоением `+=`, `*=`, индексации `[]`.

Операторы могут перегружаться как при помощи метода.
Так и при помощи функции (часто, дружественной).
Исключение - оператор присваивания - он перегружается
только при помощи метода.

Оператор `+` может перегружаться как функция: `operator+(a, b)`
так и как метод: `a.operator+(b)`.
Чтобы объявить функцию дружественной классу, необходимо
в классе написать `friend` и сигнатуру функции.

## Композиция классов

Композиция классов - это включение одного или нескольких объектов
в качестве полей класса.
```
class Vector {
    int* data;
    int size;
public:
    // ...
};

class Matrix {
    int rowCount;
    int colCount;
    Vector** cols;
    // ...
};
```
Класс матрицы `Matrix` состоит из массива объектов 
класса `Vector` - композиция классов.

```
class Point {
    int x;
    int y;
public:
    Point(int x, int y);
    void move(int deltaX, int deltaY);
};

// Плохой пример наследования
// Окружность ЭТО не точка - не наследование
// Окружность СОСТОИТ ИЗ точки (центра) - композиция
class Circle : public Point {
    int radius;
public:
    Circle(int x, int y, int radius) : Point(x, y), 
        radius(radius) {}
};

int main() {
    Point p(2, 3);
    Circle c(2, 3, 4);
    c.move(-1, 2);
    p = c; // приведение окружности к точке
    return 0;
}
```

Если соблюдается отношение ЭТО, т.е. можно сказать, например,
что объект `B b` - это частный случай объекта `A`, то можно
использовать наследование: `B` наследует `A`.
Тогда говорят, что `A` - базовый (родительский) класс,
`B` - порожденный (дочерний) класс или класс-наследник.
Любой экземпляр класса наследника совместим
с базовым классом, и может рассматриваться как 
объект базового класса.
В первых `sizeof(<базовый класс>)` байтах класса-наследника
содержатся поля базового класса.

### Статический полимозфизм

Когда на этапе компиляции устанавлиется соответствие между
именем метода (функции) и ее адресом, говорят о _раннем связывании_.
Статический полиморфизм - это полиморфизм на этапе компиляции за
счет раннего связывания.
При статическом полиморфизме функции, работающие с базовым классом,
работаю с экземплярами класса-наследника абсолютно идентично
работе с базовым классом (вызыются методы базового класса).




